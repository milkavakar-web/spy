<!doctype html>
<html lang="ru">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>–®–ø–∏–æ–Ω ‚Äî party game</title>

    <!-- SheetJS (XLSX parser) -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

    <style>
        :root{
            --bg:#0b0f19;
            --card:#121a2a;
            --muted:#93a4c7;
            --text:#eaf0ff;
            --accent:#7aa7ff;
            --danger:#ff6b6b;
            --ok:#5eead4;
            --border:rgba(255,255,255,.08);
        }
        *{box-sizing:border-box}
        body{
            margin:0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            background: radial-gradient(1200px 600px at 30% 0%, rgba(122,167,255,.18), transparent),
            radial-gradient(900px 500px at 80% 20%, rgba(94,234,212,.10), transparent),
            var(--bg);
            color:var(--text);
            min-height:100vh;
            display:flex;
            justify-content:center;
            padding: 18px 12px 32px;
        }
        .app{width:min(720px,100%);}
        .header{
            display:flex; align-items:center; justify-content:space-between;
            margin: 6px 0 14px;
            gap: 12px;
            flex-wrap:wrap;
        }
        .title{
            font-weight:800; font-size:20px; letter-spacing:.2px;
            display:flex; align-items:center; gap:10px;
        }
        .badge{
            font-size:12px; color:var(--muted);
            border:1px solid var(--border);
            padding:4px 8px; border-radius:999px;
            background: rgba(255,255,255,.03);
        }
        .card{
            background: rgba(18,26,42,.92);
            border:1px solid var(--border);
            border-radius:16px;
            padding:16px;
            box-shadow: 0 12px 30px rgba(0,0,0,.35);
            backdrop-filter: blur(6px);
        }
        .row{display:flex; gap:12px; flex-wrap:wrap;}
        .col{flex:1; min-width: 220px;}
        label{display:block; font-size:12px; color:var(--muted); margin:8px 0 6px;}
        input[type="number"], select, input[type="text"]{
            width:100%;
            padding:12px 12px;
            border-radius:12px;
            border:1px solid var(--border);
            background: rgba(255,255,255,.03);
            color:var(--text);
            outline:none;
            font-size:16px;
        }
        input[type="text"]{letter-spacing:.2px;}
        .btnbar{display:flex; gap:10px; flex-wrap:wrap; margin-top:14px;}
        button{
            cursor:pointer;
            border:none;
            border-radius:12px;
            padding:12px 14px;
            background: rgba(255,255,255,.06);
            color:var(--text);
            font-weight:700;
            font-size:15px;
        }
        button.primary{background: linear-gradient(135deg, rgba(122,167,255,.95), rgba(122,167,255,.65)); color:#071024;}
        button.danger{background: linear-gradient(135deg, rgba(255,107,107,.95), rgba(255,107,107,.65)); color:#220707;}
        button.ok{background: linear-gradient(135deg, rgba(94,234,212,.95), rgba(94,234,212,.65)); color:#041514;}
        button:disabled{opacity:.5; cursor:not-allowed;}
        .hint{color:var(--muted); font-size:13px; line-height:1.35; margin-top:10px;}
        .big{
            text-align:center;
            padding: 22px 14px;
            border-radius:16px;
            border:1px dashed rgba(255,255,255,.16);
            background: rgba(255,255,255,.03);
            margin-top: 12px;
        }
        .big .kicker{color:var(--muted); font-size:12px; margin-bottom:10px; letter-spacing:.25px;}
        .big .main{font-size:28px; font-weight:900; line-height:1.1; word-break:break-word;}
        .big .sub{margin-top:10px; color:var(--muted); font-size:13px;}
        .pill{
            display:inline-flex; gap:8px; align-items:center;
            padding:8px 10px; border-radius:999px;
            border:1px solid var(--border);
            background: rgba(255,255,255,.03);
            color:var(--muted);
            font-size:13px;
        }
        .timer{
            font-variant-numeric: tabular-nums;
            font-weight:900;
            font-size:38px;
            text-align:center;
            margin: 6px 0 4px;
            letter-spacing: .5px;
        }
        .center{ text-align:center; }
        .list{
            display:flex; flex-direction:column; gap:8px; margin-top:10px;
        }
        .choice{
            display:flex; align-items:center; justify-content:space-between;
            padding: 12px 12px;
            border-radius:12px;
            border:1px solid var(--border);
            background: rgba(255,255,255,.03);
        }
        .choice b{font-size:15px;}
        .choice small{color:var(--muted);}
        .split{
            display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;
            margin-top: 10px;
        }
        .note{
            margin-top:10px; padding:10px 12px;
            border-radius:12px; border:1px solid var(--border);
            background: rgba(255,255,255,.03);
            color:var(--muted);
            font-size:13px;
            line-height:1.35;
        }
        .hr{
            height:1px; background: rgba(255,255,255,.08);
            margin: 14px 0;
        }
        .footer{
            margin-top:12px; color:var(--muted); font-size:12px; text-align:center;
        }

        /* phone-friendly +/- rows */
        .numRow{display:flex; gap:10px; align-items:center; flex-wrap:nowrap;}
        .numBtn{min-width:54px; padding:12px 0; font-size:20px; font-weight:900;}

        /* My words management */
        .section{
            margin-top: 14px;
            padding: 12px;
            border-radius: 14px;
            border: 1px solid var(--border);
            background: rgba(255,255,255,.03);
        }
        .sectionTitle{
            display:flex;
            align-items:center;
            justify-content:space-between;
            gap:12px;
            flex-wrap:wrap;
            margin-bottom: 8px;
        }
        .sectionTitle b{font-size:14px;}
        .miniBtn{
            padding:8px 10px;
            font-size:13px;
            border-radius:10px;
        }
        .chips{
            display:flex;
            gap:8px;
            flex-wrap:wrap;
            margin-top: 8px;
        }
        .chip{
            display:inline-flex;
            align-items:center;
            gap:8px;
            padding:8px 10px;
            border-radius:999px;
            border:1px solid var(--border);
            background: rgba(255,255,255,.03);
            color: var(--text);
            font-size:13px;
            line-height:1;
            max-width: 100%;
        }
        .chip small{color:var(--muted);}
        .xBtn{
            border:none;
            background: rgba(255,255,255,.08);
            color: var(--text);
            border-radius: 999px;
            padding: 4px 8px;
            cursor:pointer;
            font-weight:900;
        }
        .dangerLink{
            color: var(--danger);
            text-decoration: underline;
            cursor: pointer;
            font-weight: 700;
            font-size: 13px;
        }
    </style>
</head>
<body>
<div class="app">
    <div class="header">
        <div class="title">üïµÔ∏è –®–ø–∏–æ–Ω </div>
        <div id="phaseBadge" class="pill">‚Ä¶</div>
    </div>
    <div id="root" class="card"></div>
    <div class="footer"></div>
</div>

<script>
    (() => {
        const $ = (sel) => document.querySelector(sel);

        // ---------- utils ----------
        function shuffle(arr){
            const a = arr.slice();
            for(let i=a.length-1;i>0;i--){
                const j = Math.floor(Math.random()*(i+1));
                [a[i], a[j]] = [a[j], a[i]];
            }
            return a;
        }
        function pickRandom(arr){ return arr[Math.floor(Math.random() * arr.length)]; }
        function randInt(min, maxInclusive){ return Math.floor(Math.random() * (maxInclusive - min + 1)) + min; }
        function formatTime(seconds){
            const s = Math.max(0, Math.floor(seconds));
            const mm = String(Math.floor(s/60)).padStart(2,'0');
            const ss = String(s%60).padStart(2,'0');
            return `${mm}:${ss}`;
        }
        function normalizeWord(str){
            return (str || "")
                .toLowerCase()
                .trim()
                .replace(/\s+/g, " ")
                .replace(/[—ë]/g, "–µ")
                .replace(/[^a-z–∞-—è0-9 ]/gi, "");
        }
        function cleanName(str){
            return (str || "").trim().replace(/\s+/g, " ");
        }
        function makeSpySet(players, spies){
            const idxs = shuffle([...Array(players).keys()]).slice(0, spies);
            return new Set(idxs);
        }
        function directionLabel(dir){ return dir === "cw" ? "–ø–æ —á–∞—Å–æ–≤–æ–π" : "–ø—Ä–æ—Ç–∏–≤ —á–∞—Å–æ–≤–æ–π"; }

        // ---------- LocalStorage user words ----------
        const USER_WORDS_KEY = "spy_user_words_v1";

        function loadUserWords(){
            try{
                const raw = localStorage.getItem(USER_WORDS_KEY);
                if (!raw) return {};
                const obj = JSON.parse(raw);
                if (!obj || typeof obj !== "object") return {};
                // expect { [category]: [word, ...] }
                for (const k of Object.keys(obj)){
                    if (!Array.isArray(obj[k])) obj[k] = [];
                    obj[k] = obj[k].map(x => cleanName(String(x))).filter(Boolean);
                }
                return obj;
            } catch(e){
                return {};
            }
        }

        function saveUserWords(){
            try{
                localStorage.setItem(USER_WORDS_KEY, JSON.stringify(state.userWords));
            } catch(e){
                alert("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å. –í–æ–∑–º–æ–∂–Ω–æ, –±—Ä–∞—É–∑–µ—Ä –∑–∞–ø—Ä–µ—â–∞–µ—Ç LocalStorage –∏–ª–∏ –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç –º–µ—Å—Ç–∞.");
            }
        }

        function dedupWords(words){
            const out = [];
            const seen = new Set();
            for (const w of words){
                const n = normalizeWord(w);
                if (!n) continue;
                if (seen.has(n)) continue;
                seen.add(n);
                out.push(w);
            }
            return out;
        }

        function userCategoriesSorted(){
            return Object.keys(state.userWords)
                .map(cleanName)
                .filter(Boolean)
                .sort((a,b) => a.localeCompare(b, "ru"));
        }

        // ---------- state ----------
        const state = {
            phase: "setup",
            settings: {
                players: 6,
                spies: 1,
                timerMode: "5",
                pack: "–í—Å–µ",
                customWord: ""
            },

            // runtime
            word: null,
            spySet: new Set(),
            reveal: { currentPlayer: 1, shown: false },
            round: {
                secondsLeft: 300,
                running: false,
                intervalId: null,
                startPlayer: null,
                direction: null
            },
            voting: { currentVoter: 1, chosen: [], finalSuspect: null, tieNote: null },
            spycall: { input: "", returnPhase: "round" },
            result: { winner: null, spyWon: false, endedBy: null },

            // base wordbook from excel
            baseWordbook: { },                 // categories only (no "–í—Å–µ")
            baseStatus: "loading",             // loading | loaded | empty | error
            baseError: null,

            // user wordbook from localStorage
            userWords: loadUserWords(),        // { category: [word...] }
            manage: {
                newCategoryName: "",
                addToCategory: "",
                newWord: ""
            },

            // merged packs used by the game
            wordbook: { "–í—Å–µ": [] },           // includes base + user, with "–í—Å–µ"
        };

        function setPhase(phase){ state.phase = phase; render(); }

        function getTimerSeconds(){
            const m = state.settings.timerMode;
            if (m === "off") return 0;
            return parseInt(m, 10) * 60;
        }
        function stopTimer(){
            if (state.round.intervalId) clearInterval(state.round.intervalId);
            state.round.intervalId = null;
            state.round.running = false;
        }
        function resetRuntimeKeepSettings(){
            stopTimer();
            state.word = null;
            state.spySet = new Set();
            state.reveal = { currentPlayer: 1, shown: false };
            state.round = { secondsLeft: getTimerSeconds(), running:false, intervalId:null, startPlayer:null, direction:null };
            state.voting = { currentVoter: 1, chosen: [], finalSuspect: null, tieNote: null };
            state.spycall = { input: "", returnPhase: "round" };
            state.result = { winner: null, spyWon: false, endedBy: null };
        }
        function finalizeStartOrder(){
            state.round.startPlayer = randInt(1, state.settings.players);
            state.round.direction = (Math.random() < 0.5) ? "cw" : "ccw";
        }

        // ---------- merge base + user into state.wordbook ----------
        function rebuildMergedWordbook(){
            // start from base
            const merged = {};
            for (const cat of Object.keys(state.baseWordbook || {})){
                const baseWords = Array.isArray(state.baseWordbook[cat]) ? state.baseWordbook[cat] : [];
                merged[cat] = dedupWords(baseWords.map(cleanName));
            }

            // overlay user words (merge by category name)
            for (const catRaw of Object.keys(state.userWords || {})){
                const cat = cleanName(catRaw);
                if (!cat) continue;
                const userList = Array.isArray(state.userWords[catRaw]) ? state.userWords[catRaw] : [];
                const combined = (merged[cat] || []).concat(userList.map(cleanName));
                merged[cat] = dedupWords(combined);
            }

            // build "–í—Å–µ"
            const all = Object.values(merged).flat();
            const allDedup = dedupWords(all);

            // final wordbook with "–í—Å–µ"
            const finalBook = { "–í—Å–µ": allDedup };
            // stable ordering for UI (alphabetical)
            const cats = Object.keys(merged).sort((a,b)=>a.localeCompare(b, "ru"));
            for (const c of cats) finalBook[c] = merged[c];

            state.wordbook = finalBook;

            // keep current selection valid
            if (!state.wordbook[state.settings.pack]) {
                state.settings.pack = "–í—Å–µ";
            }
        }

        function getPackNames(){
            const keys = Object.keys(state.wordbook || {});
            const others = keys.filter(k => k !== "–í—Å–µ").sort((a,b) => a.localeCompare(b, "ru"));
            return ["–í—Å–µ", ...others];
        }

        // ---------- load base words from excel ----------
        async function loadWordsFromExcel(){
            state.baseStatus = "loading";
            state.baseError = null;
            render();

            try{
                if (!window.XLSX) throw new Error("XLSX library not loaded");

                const res = await fetch("./words.xlsx", { cache: "no-store" });
                if (!res.ok) throw new Error(`words.xlsx not found (HTTP ${res.status})`);

                const ab = await res.arrayBuffer();
                const wb = XLSX.read(ab, { type: "array" });
                const sheetName = wb.SheetNames[0];
                if (!sheetName) throw new Error("No sheets in words.xlsx");
                const ws = wb.Sheets[sheetName];

                const rows = XLSX.utils.sheet_to_json(ws, { defval: "", raw: false });

                const packs = {};
                const seen = new Set(); // dedup base by category||word normalized

                for (const r of rows){
                    const keys = Object.keys(r);
                    const get = (name) => {
                        const k = keys.find(x => String(x).toLowerCase().trim() === name);
                        return k ? r[k] : "";
                    };

                    const category = cleanName(String(get("category")));
                    const word = cleanName(String(get("word")));
                    if (!category || !word) continue;

                    const dedupKey = `${category}||${normalizeWord(word)}`;
                    if (seen.has(dedupKey)) continue;
                    seen.add(dedupKey);

                    if (!packs[category]) packs[category] = [];
                    packs[category].push(word);
                }

                const total = Object.values(packs).flat().length;
                if (total === 0){
                    state.baseStatus = "empty";
                    state.baseWordbook = {};
                } else {
                    state.baseStatus = "loaded";
                    // dedup within each category just in case
                    for (const c of Object.keys(packs)) packs[c] = dedupWords(packs[c]);
                    state.baseWordbook = packs;
                }
            } catch(e){
                state.baseStatus = "error";
                state.baseError = e?.message || String(e);
                state.baseWordbook = {};
            }

            rebuildMergedWordbook();
            render();
        }

        // ---------- user words actions ----------
        function addCategory(){
            const name = cleanName(state.manage.newCategoryName);
            if (!name){
                alert("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.");
                return;
            }
            if (!state.userWords[name]) state.userWords[name] = [];
            state.manage.newCategoryName = "";
            // default add-to category = this one
            state.manage.addToCategory = name;
            saveUserWords();
            rebuildMergedWordbook();
            render();
        }

        function addWord(){
            const cat = cleanName(state.manage.addToCategory);
            const word = cleanName(state.manage.newWord);
            if (!cat){
                alert("–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é.");
                return;
            }
            if (!word){
                alert("–í–≤–µ–¥–∏—Ç–µ —Å–ª–æ–≤–æ.");
                return;
            }

            if (!state.userWords[cat]) state.userWords[cat] = [];
            const combined = state.userWords[cat].concat([word]);
            state.userWords[cat] = dedupWords(combined);
            state.manage.newWord = "";

            saveUserWords();
            rebuildMergedWordbook();
            render();
        }

        function deleteUserWord(category, word){
            const cat = cleanName(category);
            if (!state.userWords[cat]) return;
            state.userWords[cat] = state.userWords[cat].filter(w => normalizeWord(w) !== normalizeWord(word));
            if (state.userWords[cat].length === 0){
                // keep empty category? better keep (user may want), but user asked can delete themselves
                // We'll keep empty category so it stays visible; but allow delete category button.
            }
            saveUserWords();
            rebuildMergedWordbook();
            render();
        }

        function deleteUserCategory(category){
            const cat = cleanName(category);
            if (!state.userWords[cat]) return;
            if (!confirm(`–£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é "${cat}" –∏ –≤—Å–µ –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–µ –≤ –Ω–µ—ë —Å–ª–æ–≤–∞?`)) return;
            delete state.userWords[cat];
            saveUserWords();
            rebuildMergedWordbook();
            render();
        }

        function clearAllUserWords(){
            if (!confirm("–£–¥–∞–ª–∏—Ç—å –í–°–ï –≤–∞—à–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏ —Å–ª–æ–≤–∞ (LocalStorage)?")) return;
            state.userWords = {};
            state.manage.newCategoryName = "";
            state.manage.addToCategory = "";
            state.manage.newWord = "";
            saveUserWords();
            rebuildMergedWordbook();
            render();
        }

        // ---------- game flow ----------
        function startGame(){
            resetRuntimeKeepSettings();

            const custom = (state.settings.customWord || "").trim();
            if (custom){
                state.word = custom;
                state.settings.customWord = ""; // one-time
            } else {
                const pack = state.settings.pack || "–í—Å–µ";
                const words = (state.wordbook[pack] || []).filter(Boolean);
                if (!words.length){
                    alert("–í –≤—ã–±—Ä–∞–Ω–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –Ω–µ—Ç —Å–ª–æ–≤. –î–æ–±–∞–≤—å—Ç–µ —Å–ª–æ–≤–∞ –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥—É—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é.");
                    return;
                }
                state.word = pickRandom(words);
            }

            state.spySet = makeSpySet(state.settings.players, state.settings.spies);
            setPhase("reveal");
        }

        function nextRevealStep(){
            if (!state.reveal.shown){
                state.reveal.shown = true;
                render();
                return;
            }
            state.reveal.shown = false;
            state.reveal.currentPlayer += 1;

            if (state.reveal.currentPlayer > state.settings.players){
                finalizeStartOrder();
                setPhase("ready");
            } else {
                render();
            }
        }

        function startRound(){
            setPhase("round");
            if (state.settings.timerMode !== "off"){
                state.round.running = true;
                tickTimer();
                state.round.intervalId = setInterval(tickTimer, 1000);
            }
        }

        function tickTimer(){
            if (state.settings.timerMode === "off") return;
            state.round.secondsLeft -= 1;
            if (state.round.secondsLeft <= 0){
                state.round.secondsLeft = 0;
                stopTimer();
                setPhase("voting");
                return;
            }
            const t = $("#timerText");
            if (t) t.textContent = formatTime(state.round.secondsLeft);
        }

        function goToVoting(){ stopTimer(); setPhase("voting"); }

        function openSpyCall(fromPhase){
            state.spycall.input = "";
            state.spycall.returnPhase = fromPhase || "round";
            setPhase("spycall");
        }
        function cancelSpyCall(){ setPhase(state.spycall.returnPhase || "round"); }
        function submitSpyCall(){
            const guess = normalizeWord(state.spycall.input);
            const word = normalizeWord(state.word);
            if (!guess){ alert("–í–≤–µ–¥–∏—Ç–µ —Å–ª–æ–≤–æ."); return; }

            state.result.endedBy = "spycall";
            if (guess === word){
                state.result.spyWon = true;
                state.result.winner = "–®–ø–∏–æ–Ω(—ã)";
            } else {
                state.result.spyWon = false;
                state.result.winner = "–ò–≥—Ä–æ–∫–∏";
            }
            setPhase("result");
        }

        function voteFor(playerNumber){
            const voter = state.voting.currentVoter;
            state.voting.chosen[voter - 1] = playerNumber;
            state.voting.currentVoter += 1;

            if (state.voting.currentVoter > state.settings.players){
                finalizeVoting();
            } else {
                render();
            }
        }

        function finalizeVoting(){
            const counts = new Map();
            for (const p of state.voting.chosen){
                counts.set(p, (counts.get(p) || 0) + 1);
            }
            let max = -1;
            let top = [];
            for (const [p, c] of counts.entries()){
                if (c > max){ max = c; top = [p]; }
                else if (c === max){ top.push(p); }
            }

            if (top.length === 1){
                state.voting.finalSuspect = top[0];
                state.voting.tieNote = null;
            } else {
                state.voting.finalSuspect = pickRandom(top);
                state.voting.tieNote = `–ù–∏—á—å—è –º–µ–∂–¥—É: ${top.map(n=>`–ò–≥—Ä–æ–∫ ${n}`).join(", ")}. –°–ª—É—á–∞–π–Ω–æ –≤—ã–±—Ä–∞–Ω–æ: –ò–≥—Ä–æ–∫ ${state.voting.finalSuspect}.`;
            }

            const suspectIsSpy = state.spySet.has(state.voting.finalSuspect - 1);

            state.result.endedBy = "voting";
            if (suspectIsSpy){
                state.result.spyWon = false;
                state.result.winner = "–ò–≥—Ä–æ–∫–∏";
            } else {
                state.result.spyWon = true;
                state.result.winner = "–®–ø–∏–æ–Ω(—ã)";
            }
            setPhase("result");
        }

        function newGame(){
            resetRuntimeKeepSettings();
            state.settings.customWord = "";
            setPhase("setup");
        }
        function playAgainSameSettings(){ startGame(); }

        // ---------- UI ----------
        function phaseTitle(){
            switch(state.phase){
                case "setup": return "–ù–∞—Å—Ç—Ä–æ–π–∫–∞";
                case "reveal": return "–†–∞–∑–¥–∞—á–∞ —Ä–æ–ª–µ–π";
                case "ready": return "–°—Ç–∞—Ä—Ç –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ";
                case "round": return "–†–∞—É–Ω–¥";
                case "voting": return "–ì–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ";
                case "spycall": return "–ù–∞–∑–≤–∞—Ç—å —Å–ª–æ–≤–æ";
                case "result": return "–†–µ–∑—É–ª—å—Ç–∞—Ç";
                default: return state.phase;
            }
        }

        function render(){
            $("#phaseBadge").textContent = `–≠—Ç–∞–ø: ${phaseTitle()}`;
            const root = $("#root");
            if (!root) return;

            // ---- SETUP ----
            if (state.phase === "setup"){
                // ensure merged wordbook is current (in case userWords loaded before excel)
                rebuildMergedWordbook();

                const packs = getPackNames();
                const canPickPack = (packs.length > 0);

                const packOptions = packs.map(name => {
                    const n = (state.wordbook[name] || []).length;
                    return `<option value="${name}" ${state.settings.pack===name?"selected":""}>${name} (${n})</option>`;
                }).join("");

                // manage-category list for adding word (exclude "–í—Å–µ")
                const addCatOptions = packs
                    .filter(n => n !== "–í—Å–µ")
                    .map(name => `<option value="${name}" ${cleanName(state.manage.addToCategory)===name?"selected":""}>${name}</option>`)
                    .join("");

                // excel status text
                let baseStatusText = "";
                if (state.baseStatus === "loading") baseStatusText = "‚è≥ –ó–∞–≥—Ä—É–∂–∞—é –±–∞–∑–æ–≤—ã–µ —Å–ª–æ–≤–∞ –∏–∑ words.xlsx‚Ä¶";
                if (state.baseStatus === "loaded"){
                    const baseTotal = Object.values(state.baseWordbook).flat().length;
                    baseStatusText = `‚úÖ –ë–∞–∑–æ–≤—ã—Ö —Å–ª–æ–≤: ${baseTotal}.`;
                }
                if (state.baseStatus === "empty") baseStatusText = "‚ö†Ô∏è words.xlsx –ø—Ä–æ—á–∏—Ç–∞–Ω, –Ω–æ —Å–ª–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ (–ø—Ä–æ–≤–µ—Ä—å –∫–æ–ª–æ–Ω–∫–∏ category/word).";
                if (state.baseStatus === "error") baseStatusText = `‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å words.xlsx: ${state.baseError || "unknown error"}.`;

                const userCats = userCategoriesSorted();

                root.innerHTML = `
        <div class="note" id="statusBox"></div>

        <div class="row">
          <div class="col">
            <label>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–≥—Ä–æ–∫–æ–≤</label>
            <div class="numRow">
              <button id="playersMinus" type="button" class="numBtn">‚àí</button>
              <input id="players" type="text" inputmode="numeric" pattern="[0-9]*" value="${state.settings.players}" />
              <button id="playersPlus" type="button" class="numBtn">+</button>
            </div>
            <div class="hint">–í–≤–µ–¥–∏ –ª—é–±–æ–µ —á–∏—Å–ª–æ (–º–∏–Ω–∏–º—É–º 3).</div>
          </div>

          <div class="col">
            <label>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —à–ø–∏–æ–Ω–æ–≤</label>
            <div class="numRow">
              <button id="spiesMinus" type="button" class="numBtn">‚àí</button>
              <input id="spies" type="text" inputmode="numeric" pattern="[0-9]*" value="${state.settings.spies}" />
              <button id="spiesPlus" type="button" class="numBtn">+</button>
            </div>
            <div class="hint">–õ—é–±–æ–µ —á–∏—Å–ª–æ, –Ω–æ –º–µ–Ω—å—à–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∏–≥—Ä–æ–∫–æ–≤.</div>
          </div>
        </div>

        <label>–°–≤–æ—ë —Å–ª–æ–≤–æ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, –æ–¥–Ω–æ—Ä–∞–∑–æ–≤–æ)</label>
        <input id="customWord" type="text" placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä: –®—Ä–µ–∫" value="${state.settings.customWord || ""}" />
        <div class="hint">–ï—Å–ª–∏ –∑–∞–ø–æ–ª–Ω–µ–Ω–æ ‚Äî –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏–≥–Ω–æ—Ä–∏—Ä—É—é—Ç—Å—è. –ü–æ—Å–ª–µ —Å—Ç–∞—Ä—Ç–∞ –∏–≥—Ä—ã –ø–æ–ª–µ –æ—á–∏—Å—Ç–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.</div>

        <div class="row">
          <div class="col">
            <label>–¢–∞–π–º–µ—Ä —Ä–∞—É–Ω–¥–∞</label>
            <select id="timer">
              <option value="off" ${state.settings.timerMode==="off"?"selected":""}>–ë–µ–∑ —Ç–∞–π–º–µ—Ä–∞</option>
              <option value="3" ${state.settings.timerMode==="3"?"selected":""}>3 –º–∏–Ω—É—Ç—ã</option>
              <option value="5" ${state.settings.timerMode==="5"?"selected":""}>5 –º–∏–Ω—É—Ç</option>
              <option value="7" ${state.settings.timerMode==="7"?"selected":""}>7 –º–∏–Ω—É—Ç</option>
              <option value="10" ${state.settings.timerMode==="10"?"selected":""}>10 –º–∏–Ω—É—Ç</option>
            </select>
          </div>

          <div class="col">
            <label>–ö–∞—Ç–µ–≥–æ—Ä–∏—è –¥–ª—è –∏–≥—Ä—ã (–±–∞–∑–∞ + –º–æ–∏ —Å–ª–æ–≤–∞)</label>
            <select id="pack" ${canPickPack ? "" : "disabled"}>
              ${packOptions}
            </select>
          </div>
        </div>

        <div class="note" id="setupNote"></div>

        <div class="btnbar">
          <button class="primary" id="startBtn">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
        </div>

        <div class="section">
          <div class="sectionTitle">
            <b>–ú–æ–∏ —Å–ª–æ–≤–∞ (—Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ)</b>
            <button class="miniBtn danger" id="clearAllBtn" ${userCats.length ? "" : "disabled"}>–£–¥–∞–ª–∏—Ç—å –≤—Å—ë</button>
          </div>

          <div class="row">
            <div class="col">
              <label>–ù–æ–≤–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è</label>
              <input id="newCategory" type="text" placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä: –ò–≥—Ä—ã" value="${state.manage.newCategoryName || ""}" />
              <div class="btnbar" style="margin-top:10px;">
                <button class="ok" id="addCategoryBtn">–î–æ–±–∞–≤–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é</button>
              </div>
            </div>

            <div class="col">
              <label>–î–æ–±–∞–≤–∏—Ç—å —Å–ª–æ–≤–æ –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏—é</label>
              <select id="addToCategory">
                <option value="" ${!state.manage.addToCategory ? "selected" : ""}>‚Äî –≤—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é ‚Äî</option>
                ${addCatOptions}
              </select>
              <label>–°–ª–æ–≤–æ</label>
              <input id="newWord" type="text" placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä: –í–µ–¥—å–º–∞–∫" value="${state.manage.newWord || ""}" />
              <div class="btnbar" style="margin-top:10px;">
                <button class="ok" id="addWordBtn">–î–æ–±–∞–≤–∏—Ç—å —Å–ª–æ–≤–æ</button>
              </div>
              <div class="hint">–ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–ª—è—Ç—å —Å–ª–æ–≤–∞ –∏ –≤ ‚Äú–±–∞–∑–æ–≤—ã–µ‚Äù –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ ‚Äî –æ–Ω–∏ –ø—Ä–æ—Å—Ç–æ –±—É–¥—É—Ç —Ö—Ä–∞–Ω–∏—Ç—å—Å—è –∫–∞–∫ –≤–∞—à–∏.</div>
            </div>
          </div>

          <div class="hr"></div>
          <div class="hint" style="margin-top:0;">
            –ù–∏–∂–µ –ø–æ–∫–∞–∑–∞–Ω—ã —Ç–æ–ª—å–∫–æ —Å–ª–æ–≤–∞, –∫–æ—Ç–æ—Ä—ã–µ –¥–æ–±–∞–≤–∏–ª–∏ –≤—ã:
          </div>

          <div id="userWordsList"></div>
        </div>
      `;

                // status box text
                const statusBox = $("#statusBox");
                const totalMerged = (state.wordbook["–í—Å–µ"] || []).length;
                const userTotal = Object.values(state.userWords || {}).flat().length;
                statusBox.textContent = `${baseStatusText} ‚≠ê –í—Å–µ–≥–æ —Å–ª–æ–≤ (—Å —É—á—ë—Ç–æ–º –º–æ–∏—Ö): ${totalMerged}. –ú–æ–∏ —Å–ª–æ–≤–∞: ${userTotal}.`;

                const playersEl = $("#players");
                const spiesEl = $("#spies");
                const timerEl = $("#timer");
                const packEl = $("#pack");
                const customEl = $("#customWord");
                const noteEl = $("#setupNote");
                const startBtn = $("#startBtn");

                const playersMinus = $("#playersMinus");
                const playersPlus  = $("#playersPlus");
                const spiesMinus   = $("#spiesMinus");
                const spiesPlus    = $("#spiesPlus");

                // manage controls
                const newCategoryEl = $("#newCategory");
                const addCategoryBtn = $("#addCategoryBtn");
                const addToCategoryEl = $("#addToCategory");
                const newWordEl = $("#newWord");
                const addWordBtn = $("#addWordBtn");
                const clearAllBtn = $("#clearAllBtn");

                function validateAndFix(){
                    let players = parseInt(playersEl.value, 10);
                    if (Number.isNaN(players)) players = 6;
                    players = Math.max(3, players);

                    let spies = parseInt(spiesEl.value, 10);
                    if (Number.isNaN(spies)) spies = 1;
                    spies = Math.max(1, spies);
                    if (spies >= players) spies = players - 1;

                    playersEl.value = String(players);
                    spiesEl.value = String(spies);

                    state.settings.players = players;
                    state.settings.spies = spies;
                    state.settings.timerMode = timerEl.value;
                    if (packEl) state.settings.pack = packEl.value || "–í—Å–µ";
                    state.settings.customWord = customEl.value;

                    const warnings = [];
                    if (spies >= Math.ceil(players/2)) warnings.push("‚ö†Ô∏è –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ —à–ø–∏–æ–Ω–æ–≤ ‚Äî –∏–≥—Ä–æ–∫–∞–º –º–æ–∂–µ—Ç –±—ã—Ç—å —Å–ª–æ–∂–Ω–æ.");

                    const hasCustomNow = (state.settings.customWord || "").trim().length > 0;
                    if (hasCustomNow) {
                        warnings.push("‚úÖ –ë—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ —Å–≤–æ—ë —Å–ª–æ–≤–æ (–æ–¥–Ω–æ—Ä–∞–∑–æ–≤–æ).");
                    } else {
                        const count = (state.wordbook[state.settings.pack] || []).length;
                        warnings.push(count ? `‚úÖ –í –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ "${state.settings.pack}" —Å–ª–æ–≤: ${count}` : "‚ö†Ô∏è –í —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –Ω–µ—Ç —Å–ª–æ–≤.");
                    }

                    noteEl.textContent = warnings.join(" ");

                    let okToStart = false;
                    if (hasCustomNow) okToStart = true;
                    else if ((state.wordbook[state.settings.pack] || []).length > 0) okToStart = true;

                    startBtn.disabled = !okToStart;
                }

                // +/- handlers
                playersMinus.addEventListener("click", () => {
                    const v = parseInt(playersEl.value, 10);
                    playersEl.value = String((Number.isNaN(v) ? 6 : v) - 1);
                    validateAndFix();
                });
                playersPlus.addEventListener("click", () => {
                    const v = parseInt(playersEl.value, 10);
                    playersEl.value = String((Number.isNaN(v) ? 6 : v) + 1);
                    validateAndFix();
                });
                spiesMinus.addEventListener("click", () => {
                    const v = parseInt(spiesEl.value, 10);
                    spiesEl.value = String((Number.isNaN(v) ? 1 : v) - 1);
                    validateAndFix();
                });
                spiesPlus.addEventListener("click", () => {
                    const v = parseInt(spiesEl.value, 10);
                    spiesEl.value = String((Number.isNaN(v) ? 1 : v) + 1);
                    validateAndFix();
                });

                playersEl.addEventListener("input", validateAndFix);
                spiesEl.addEventListener("input", validateAndFix);
                timerEl.addEventListener("change", validateAndFix);
                if (packEl) packEl.addEventListener("change", validateAndFix);
                customEl.addEventListener("input", validateAndFix);

                startBtn.addEventListener("click", startGame);

                // manage handlers
                newCategoryEl.addEventListener("input", () => state.manage.newCategoryName = newCategoryEl.value);
                addToCategoryEl.addEventListener("change", () => state.manage.addToCategory = addToCategoryEl.value);
                newWordEl.addEventListener("input", () => state.manage.newWord = newWordEl.value);

                addCategoryBtn.addEventListener("click", addCategory);
                addWordBtn.addEventListener("click", addWord);
                clearAllBtn.addEventListener("click", clearAllUserWords);

                // render user words list
                const listHost = $("#userWordsList");
                const cats = userCategoriesSorted();

                if (!cats.length){
                    listHost.innerHTML = `<div class="note">–ü–æ–∫–∞ –Ω–µ—Ç –≤–∞—à–∏—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π/—Å–ª–æ–≤. –î–æ–±–∞–≤—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏ —Å–ª–æ–≤–∞ ‚Äî –æ–Ω–∏ —Å–æ—Ö—Ä–∞–Ω—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–µ—Ä–µ–∑–∞—Ö–æ–¥–∞.</div>`;
                } else {
                    const blocks = cats.map(cat => {
                        const words = dedupWords((state.userWords[cat] || []).map(cleanName));
                        const chips = words.length ? `
            <div class="chips">
              ${words.map(w => `
                <div class="chip">
                  <span>${w}</span>
                  <button class="xBtn" data-delword="${encodeURIComponent(cat)}||${encodeURIComponent(w)}">√ó</button>
                </div>
              `).join("")}
            </div>
          ` : `<div class="hint">–í —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ–∫–∞ –Ω–µ—Ç –≤–∞—à–∏—Ö —Å–ª–æ–≤.</div>`;

                        return `
            <div class="section" style="margin-top:10px;">
              <div class="sectionTitle">
                <b>${cat}</b>
                <span class="dangerLink" data-delcat="${encodeURIComponent(cat)}">–£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é</span>
              </div>
              ${chips}
            </div>
          `;
                    }).join("");

                    listHost.innerHTML = blocks;

                    // bind delete events
                    listHost.querySelectorAll("[data-delword]").forEach(btn => {
                        btn.addEventListener("click", () => {
                            const raw = btn.getAttribute("data-delword");
                            const [cEnc, wEnc] = raw.split("||");
                            const c = decodeURIComponent(cEnc || "");
                            const w = decodeURIComponent(wEnc || "");
                            deleteUserWord(c, w);
                        });
                    });
                    listHost.querySelectorAll("[data-delcat]").forEach(el => {
                        el.addEventListener("click", () => {
                            const c = decodeURIComponent(el.getAttribute("data-delcat") || "");
                            deleteUserCategory(c);
                        });
                    });
                }

                validateAndFix();
                return;
            }

            // ---- REVEAL ----
            if (state.phase === "reveal"){
                const p = state.reveal.currentPlayer;
                const isSpy = state.spySet.has(p - 1);
                const shown = state.reveal.shown;

                root.innerHTML = `
        <div class="center"><div class="pill">–ò–≥—Ä–æ–∫ ${p} –∏–∑ ${state.settings.players}</div></div>

        <div class="big">
          ${!shown ? `
            <div class="kicker">–ü–µ—Ä–µ–¥–∞–π —Ç–µ–ª–µ—Ñ–æ–Ω –ò–≥—Ä–æ–∫—É ${p}</div>
            <div class="main">–ù–∞–∂–º–∏, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å —Ä–æ–ª—å</div>
            <div class="sub">–£–±–µ–¥–∏—Å—å, —á—Ç–æ –Ω–∏–∫—Ç–æ –Ω–µ –ø–æ–¥–≥–ª—è–¥—ã–≤–∞–µ—Ç üëÄ</div>
          ` : isSpy ? `
            <div class="kicker">–¢–≤–æ—è —Ä–æ–ª—å</div>
            <div class="main" style="color: var(--danger)">–¢–´ ‚Äî –®–ü–ò–û–ù</div>
            <div class="sub">–°–ª–æ–≤–∞ –Ω–µ—Ç. –¢—ã –º–æ–∂–µ—à—å –Ω–∞–∑–≤–∞—Ç—å —Å–ª–æ–≤–æ –≤ –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç.</div>
          ` : `
            <div class="kicker">–¢–≤–æ—ë —Å–ª–æ–≤–æ</div>
            <div class="main" style="color: var(--ok)">${state.word}</div>
            <div class="sub">–î–∞–≤–∞–π –∫–æ—Å–≤–µ–Ω–Ω—ã–µ —Ñ–∞–∫—Ç—ã, —á—Ç–æ–±—ã –≤—ã—á–∏—Å–ª–∏—Ç—å —à–ø–∏–æ–Ω–∞.</div>
          `}
        </div>

        <div class="btnbar">
          <button class="${shown ? "ok" : "primary"}" id="revealBtn">
            ${shown ? "–°–∫—Ä—ã—Ç—å –∏ –ø–µ—Ä–µ–¥–∞—Ç—å" : "–ü–æ–∫–∞–∑–∞—Ç—å —Ä–æ–ª—å"}
          </button>
          <button id="abortBtn">–û—Ç–º–µ–Ω–∞</button>
        </div>
      `;

                $("#revealBtn").addEventListener("click", nextRevealStep);
                $("#abortBtn").addEventListener("click", newGame);
                return;
            }

            // ---- READY ----
            if (state.phase === "ready"){
                const timerText = state.settings.timerMode === "off" ? "–ë–µ–∑ —Ç–∞–π–º–µ—Ä–∞" : `${state.settings.timerMode} –º–∏–Ω`;
                const sp = state.round.startPlayer ?? 1;
                const dir = state.round.direction ?? "cw";

                root.innerHTML = `
        <div class="center"><div class="pill">–°–ª–æ–≤–æ –≤—ã–±—Ä–∞–Ω–æ ‚Ä¢ –†–æ–ª–∏ –≤—ã–¥–∞–Ω—ã</div></div>

        <div class="big">
          <div class="kicker">–ö—Ç–æ –Ω–∞—á–∏–Ω–∞–µ—Ç –∏ –∫—É–¥–∞ —Ö–æ–¥–∏–º</div>
          <div class="main">–ò–≥—Ä–æ–∫ ${sp}</div>
          <div class="sub">–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: <b>${directionLabel(dir)}</b></div>
        </div>

        <div class="note">–ò–≥—Ä–æ–∫ ${sp} –¥–∞—ë—Ç –ø–µ—Ä–≤—É—é –ø–æ–¥—Å–∫–∞–∑–∫—É, –¥–∞–ª—å—à–µ —Ö–æ–¥–∏—Ç–µ <b>${directionLabel(dir)}</b>.</div>

        <div class="big" style="margin-top:12px;">
          <div class="kicker">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</div>
          <div class="sub">–¢–∞–π–º–µ—Ä: <b>${timerText}</b></div>
        </div>

        <div class="btnbar">
          <button class="primary" id="startRoundBtn">–°—Ç–∞—Ä—Ç —Ä–∞—É–Ω–¥–∞</button>
          <button id="abortBtn">–û—Ç–º–µ–Ω–∞</button>
        </div>
      `;

                $("#startRoundBtn").addEventListener("click", startRound);
                $("#abortBtn").addEventListener("click", newGame);
                return;
            }

            // ---- ROUND ----
            if (state.phase === "round"){
                const timerOff = state.settings.timerMode === "off";
                const sp = state.round.startPlayer ?? 1;
                const dir = state.round.direction ?? "cw";

                root.innerHTML = `
        <div class="center"><div class="pill">–ü–æ–¥—Å–∫–∞–∑–∫–∏ –ø–æ –∫—Ä—É–≥—É ‚Ä¢ –ù–µ –ø–∞–ª–∏—Ç–µ—Å—å üòÑ</div></div>

        <div class="note">–°—Ç–∞—Ä—Ç: <b>–ò–≥—Ä–æ–∫ ${sp}</b> ‚Ä¢ –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: <b>${directionLabel(dir)}</b></div>

        ${timerOff ? `
          <div class="big">
            <div class="kicker">–¢–∞–π–º–µ—Ä –≤—ã–∫–ª—é—á–µ–Ω</div>
            <div class="main">–ò–≥—Ä–∞–π—Ç–µ –≤ —Å–≤–æ—ë–º —Ç–µ–º–ø–µ</div>
            <div class="sub">–ö–æ–≥–¥–∞ –±—É–¥–µ—Ç–µ –≥–æ—Ç–æ–≤—ã ‚Äî –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç–µ –∫ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏—é.</div>
          </div>
        ` : `
          <div class="timer" id="timerText">${formatTime(state.round.secondsLeft)}</div>
          <div class="center"><span class="pill">–û—Å—Ç–∞–ª–æ—Å—å –≤—Ä–µ–º–µ–Ω–∏</span></div>
        `}

        <div class="btnbar">
          <button class="danger" id="voteBtn">–ì–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ</button>
          <button class="primary" id="spyCallBtn">–®–ø–∏–æ–Ω: –Ω–∞–∑–≤–∞—Ç—å —Å–ª–æ–≤–æ</button>
          <button id="abortBtn">–û—Ç–º–µ–Ω–∞</button>
        </div>
      `;

                $("#voteBtn").addEventListener("click", goToVoting);
                $("#spyCallBtn").addEventListener("click", () => openSpyCall("round"));
                $("#abortBtn").addEventListener("click", newGame);
                return;
            }

            // ---- VOTING ----
            if (state.phase === "voting"){
                const voter = state.voting.currentVoter;

                root.innerHTML = `
        <div class="center"><div class="pill">–ì–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ (–ø–µ—Ä–µ–¥–∞–≤–∞–π —Ç–µ–ª–µ—Ñ–æ–Ω)</div></div>

        <div class="big">
          <div class="kicker">–°–µ–π—á–∞—Å –≥–æ–ª–æ—Å—É–µ—Ç</div>
          <div class="main">–ò–≥—Ä–æ–∫ ${voter}</div>
          <div class="sub">–í—ã–±–µ—Ä–∏, –∫—Ç–æ –ø–æ —Ç–≤–æ–µ–º—É –º–Ω–µ–Ω–∏—é —à–ø–∏–æ–Ω</div>
        </div>

        <div class="btnbar">
          <button class="primary" id="spyCallBtn">–®–ø–∏–æ–Ω: –Ω–∞–∑–≤–∞—Ç—å —Å–ª–æ–≤–æ</button>
          <button id="abortBtn">–û—Ç–º–µ–Ω–∞</button>
        </div>

        <div class="list" id="choices"></div>
        <div class="hint">–ì–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ —Å–∫—Ä—ã—Ç–æ: –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –≥–æ–ª–æ—Å–∞ –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç—Å—è.</div>
      `;

                $("#spyCallBtn").addEventListener("click", () => openSpyCall("voting"));
                $("#abortBtn").addEventListener("click", newGame);

                const choices = $("#choices");
                const players = state.settings.players;
                for (let p=1; p<=players; p++){
                    const div = document.createElement("div");
                    div.className = "choice";
                    div.innerHTML = `<div><b>–ò–≥—Ä–æ–∫ ${p}</b><br><small>–≤—ã–±—Ä–∞—Ç—å</small></div><div>‚û°Ô∏è</div>`;
                    div.addEventListener("click", () => {
                        if (confirm(`–ò–≥—Ä–æ–∫ ${voter}, –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –≥–æ–ª–æ—Å –∑–∞ –ò–≥—Ä–æ–∫–∞ ${p}?`)){
                            voteFor(p);
                        }
                    });
                    choices.appendChild(div);
                }
                return;
            }

            // ---- SPYCALL ----
            if (state.phase === "spycall"){
                root.innerHTML = `
        <div class="center"><div class="pill">–ü–æ–ø—ã—Ç–∫–∞ –Ω–∞–∑–≤–∞—Ç—å —Å–ª–æ–≤–æ</div></div>

        <div class="big">
          <div class="kicker">–ï—Å–ª–∏ —à–ø–∏–æ–Ω —Ä–µ—à–∏–ª —Ä–∏—Å–∫–Ω—É—Ç—å</div>
          <div class="main">–ù–∞–∑–æ–≤–∏ —Å–ª–æ–≤–æ</div>
          <div class="sub">–ï—Å–ª–∏ –≤–µ—Ä–Ω–æ ‚Äî —à–ø–∏–æ–Ω(—ã) –≤—ã–∏–≥—Ä—ã–≤–∞—é—Ç. –ï—Å–ª–∏ –Ω–µ—Ç ‚Äî –≤—ã–∏–≥—Ä—ã–≤–∞—é—Ç –∏–≥—Ä–æ–∫–∏.</div>
        </div>

        <label>–°–ª–æ–≤–æ</label>
        <input id="spyInput" type="text" placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä: –®—Ä–µ–∫" value="${state.spycall.input || ""}" />

        <div class="btnbar">
          <button class="primary" id="submitSpyBtn">–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å</button>
          <button id="cancelSpyBtn">–ù–∞–∑–∞–¥</button>
        </div>
      `;

                const inp = $("#spyInput");
                inp.focus();
                inp.addEventListener("input", () => state.spycall.input = inp.value);

                $("#submitSpyBtn").addEventListener("click", submitSpyCall);
                $("#cancelSpyBtn").addEventListener("click", cancelSpyCall);
                return;
            }

            // ---- RESULT ----
            if (state.phase === "result"){
                const spies = [...state.spySet].map(i => `–ò–≥—Ä–æ–∫ ${i+1}`);
                const suspect = state.voting.finalSuspect;
                const note = state.voting.tieNote;

                const endedByVoting = state.result.endedBy === "voting";
                const endedBySpyCall = state.result.endedBy === "spycall";

                root.innerHTML = `
        <div class="center"><div class="pill">–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞</div></div>

        <div class="big">
          <div class="kicker">–ü–æ–±–µ–¥–∏—Ç–µ–ª—å</div>
          <div class="main" style="color:${state.result.spyWon ? "var(--danger)" : "var(--ok)"}">${state.result.winner}</div>
          <div class="sub">–ó–∞–≥–∞–¥–∞–Ω–Ω–æ–µ —Å–ª–æ–≤–æ: <b>${state.word}</b></div>
        </div>

        <div class="hr"></div>

        <div class="split">
          <div class="pill">–®–ø–∏–æ–Ω(—ã): <b style="color:var(--text)">${spies.join(", ")}</b></div>
          ${endedByVoting && suspect ? `<div class="pill">–í—ã–±—Ä–∞–Ω: <b style="color:var(--text)">–ò–≥—Ä–æ–∫ ${suspect}</b></div>` : ``}
          ${endedBySpyCall ? `<div class="pill">–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ: <b style="color:var(--text)">–®–ø–∏–æ–Ω –Ω–∞–∑–≤–∞–ª —Å–ª–æ–≤–æ</b></div>` : ``}
        </div>

        ${endedByVoting && note ? `<div class="note">‚ÑπÔ∏è ${note}</div>` : ""}

        ${endedByVoting ? `
          <div class="note">–ì–æ–ª–æ—Å–∞: ${state.voting.chosen.map((c, idx) => `–ò–≥—Ä–æ–∫ ${idx+1} ‚Üí –ò–≥—Ä–æ–∫ ${c}`).join(" ‚Ä¢ ")}</div>
        ` : `
          <div class="note">–ì–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ –Ω–µ –∑–∞–≤–µ—Ä—à–∞–ª–æ—Å—å, –ø–æ—Ç–æ–º—É —á—Ç–æ —à–ø–∏–æ–Ω –ø–æ–ø—ã—Ç–∞–ª—Å—è –Ω–∞–∑–≤–∞—Ç—å —Å–ª–æ–≤–æ.</div>
        `}

        <div class="btnbar">
          <button class="primary" id="againBtn">–°—ã–≥—Ä–∞—Ç—å –µ—â—ë (—Ç–µ –∂–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏)</button>
          <button id="newBtn">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
        </div>
      `;

                $("#againBtn").addEventListener("click", playAgainSameSettings);
                $("#newBtn").addEventListener("click", newGame);
                return;
            }
        }

        // init
        rebuildMergedWordbook();
        loadWordsFromExcel();
        render();
    })();
</script>
</body>
</html>
